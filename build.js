#!/usr/bin/env node
/**
 * Build script for IWantMYManhwa
 * Compiles ContentAdapter files into content.js
 * 
 * Usage: node build.js
 */

const fs = require('fs');
const path = require('path');

// Configuration
const ADAPTER_DIR = './sites';
const OUTPUT_FILE = './content.js';

// Template for the compiled content.js
// NOTE: This file is auto-generated. Edit source files in ./sites/ and run `node build.js` to rebuild.
const TEMPLATE = `// content.js (Auto-generated)
// Generated at: ${new Date().toISOString()}
// DO NOT EDIT THIS FILE DIRECTLY - Edit source files in ./sites/ and run \`node build.js\` to rebuild

'use strict';
console.log("IWantMYManhwa: Content script loaded on", window.location.href);

// ============ SITE ADAPTER CLASSES ============

{{ADAPTER_CODE}}

// ============ SITE REGISTRY ============

{{REGISTRY_CODE}}

// ============ CONTENT SCRIPT LOGIC ============

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === "getChapters") {
        console.log("[Content Script] Received request: getChapters");
        
        try {
            const currentUrl = window.location.href;
            const adapter = siteRegistry.findAdapterForUrl(currentUrl);
            
            if (!adapter) {
                console.error("[Content Script] No adapter found for URL:", currentUrl);
                sendResponse({ 
                    action: "error",
                    error: \`No adapter found for this site: \${currentUrl}\`,
                    title: 'Unknown',
                    chapters: []
                });
                return true;
            }
            
            console.log(\`[Content Script] Using adapter: \${adapter.name}\`);
            
            const chapters = adapter.getChapters();
            console.log(\`[Content Script] Found \${chapters.length} chapters.\`);
            
            const title = adapter.getTitle();
            
            sendResponse({ 
                action: "chaptersFound",
                title: title,
                chapters: chapters,
                siteName: adapter.name
            });
            
        } catch (error) {
            console.error("[Content Script] Error:", error);
            sendResponse({ 
                action: "error",
                error: error.message,
                title: 'Unknown',
                chapters: []
            });
        }
        
        return true;
    }
    
    return false;
});

chrome.runtime.sendMessage({ action: "contentScriptReady", url: window.location.href });
console.log("[Content Script] Ready");
`;

// Files to include (ContentAdapter files only - scraping only)
const CONTENT_ADAPTER_FILES = [
    'webtoonscan/WebtoonscanContentAdapter.js',
    'asurascan/AsuraScansContentAdapter.js'
];

// Registry file
const REGISTRY_FILE = 'SiteRegistry.js';
const BASE_ADAPTER_FILE = 'SiteAdapter.js';

function build() {
    console.log('Building content.js from ContentAdapter files...\n');
    
    let adapterCode = '';
    let registryCode = '';
    
    // 1. Include base adapter class first
    console.log(`  ✓ Including: ${BASE_ADAPTER_FILE}`);
    let baseContent = fs.readFileSync(path.join(ADAPTER_DIR, BASE_ADAPTER_FILE), 'utf8');
    // Remove downloadChapter method from base class
    baseContent = baseContent.replace(/\/\/ --- Download Method[\s\S]*?\n    \}\n/, '');
    adapterCode += baseContent.trim() + '\n\n';
    
    // 2. Include ContentAdapter files
    for (const file of CONTENT_ADAPTER_FILES) {
        const filePath = path.join(ADAPTER_DIR, file);
        
        if (!fs.existsSync(filePath)) {
            console.error(`Error: File not found: ${filePath}`);
            process.exit(1);
        }
        
        console.log(`  ✓ Including: ${file}`);
        let content = fs.readFileSync(filePath, 'utf8');
        
        // Remove 'use strict' (we have one at top)
        content = content.replace(/^['"]use strict['"];\s*\n?/gm, '');
        
        // Remove global exports
        content = content.replace(/\/\/ Make available globally[\s\S]*$/gm, '');
        content = content.replace(/if \(typeof window[\s\S]*?}\s*$/gm, '');
        content = content.replace(/if \(typeof globalThis[\s\S]*?}\s*$/gm, '');
        content = content.replace(/if \(typeof self[\s\S]*?}\s*$/gm, '');
        
        adapterCode += content.trim() + '\n\n';
    }
    
    // 3. Include registry (simplified for content)
    console.log(`  ✓ Including: ${REGISTRY_FILE}`);
    let registryContent = fs.readFileSync(path.join(ADAPTER_DIR, REGISTRY_FILE), 'utf8');
    
    // For content.js, we only need the essential parts
    // Remove methods not needed in content script
    registryContent = registryContent.replace(/\/\/ Export for module systems[\s\S]*$/, '');
    registryContent = registryContent.replace(/\/\/ Make available globally[\s\S]*$/gm, '');
    registryContent = registryContent.replace(/if \(typeof module[\s\S]*?}\s*$/, '');
    registryContent = registryContent.replace(/if \(typeof window[\s\S]*?}\s*$/gm, '');
    registryContent = registryContent.replace(/if \(typeof globalThis[\s\S]*?}\s*$/gm, '');
    registryContent = registryContent.replace(/if \(typeof self[\s\S]*?}\s*$/gm, '');
    registryContent = registryContent.replace(/\/\/ Create singleton instance\s*\n?/, '');
    registryContent = registryContent.replace(/const siteRegistry = new SiteRegistry\(\);\s*\n?/, '');
    // Remove the initialize method since we're overriding it
    registryContent = registryContent.replace(/\n    initialize\(\) \{[\s\S]*?\n    \}\n/, '\n');
    
    // Remove unused methods
    registryContent = registryContent.replace(/\n    getAdapterForChapterList[\s\S]*?\n    \}\n/, '\n');
    registryContent = registryContent.replace(/\n    getAdapterForChapter[\s\S]*?\n    \}\n/, '\n');
    
    registryCode = registryContent.trim() + '\n\n';
    
    // Add siteRegistry initialization at the end
    // First create the instance
    registryCode += 'const siteRegistry = new SiteRegistry();\n';
    
    // Override: use ContentAdapter for content script - BEFORE calling initialize
    registryCode += '\n';
    registryCode += '// Override: use ContentAdapter for content script\n';
    registryCode += 'siteRegistry.initialize = function() {\n';
    registryCode += '    this.adapters.clear();\n';
    for (const file of CONTENT_ADAPTER_FILES) {
        // Extract class name from file path (e.g., 'webtoonscan/WebtoonscanContentAdapter' -> 'WebtoonscanContentAdapter')
        const className = file.split('/').pop().replace('.js', '');
        // Extract adapter name (e.g., 'WebtoonscanContentAdapter' -> 'webtoonscan')
        const adapterName = className.replace('ContentAdapter', '').toLowerCase();
        registryCode += `    if (typeof ${className} !== 'undefined') this.register('${adapterName}', new ${className}(), true);\n`;
    }
    registryCode += '};\n';
    
    // NOW call initialize (after override is defined)
    registryCode += '\n';
    registryCode += 'siteRegistry.initialize();\n';
    
    // Generate final content.js
    let output = TEMPLATE.replace('{{ADAPTER_CODE}}', adapterCode.trim());
    output = output.replace('{{REGISTRY_CODE}}', registryCode.trim());
    
    // Write output file
    fs.writeFileSync(OUTPUT_FILE, output, 'utf8');
    
    const stats = fs.statSync(OUTPUT_FILE);
    console.log(`\n✓ Built: ${OUTPUT_FILE}`);
    console.log(`  Size: ${(stats.size / 1024).toFixed(2)} KB`);
    console.log(`  Lines: ${output.split('\n').length}`);
    console.log(`\nDone! Load the extension in Chrome.\n`);
}

// Watch mode (optional)
if (process.argv.includes('--watch')) {
    console.log('Watching for changes... (Press Ctrl+C to stop)\n');
    
    const watchFiles = [...CONTENT_ADAPTER_FILES, REGISTRY_FILE, BASE_ADAPTER_FILE];
    
    watchFiles.forEach(file => {
        const filePath = path.join(ADAPTER_DIR, file);
        if (fs.existsSync(filePath)) {
            fs.watchFile(filePath, () => {
                console.log(`\n${file} changed, rebuilding...`);
                try {
                    build();
                } catch (e) {
                    console.error('Build failed:', e.message);
                }
            });
        }
    });
} else {
    build();
}
