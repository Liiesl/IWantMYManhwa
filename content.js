// content.js (Auto-generated)
// Generated at: 2026-02-13T21:57:35.015Z
// DO NOT EDIT THIS FILE DIRECTLY - Edit source files in ./sites/ and run `node build.js` to rebuild

'use strict';
console.log("IWantMYManhwa: Content script loaded on", window.location.href);

// ============ SITE ADAPTER CLASSES ============

// sites/SiteAdapter.js
// Base abstract class for all site adapters

'use strict';

/**
 * Base adapter class for all manhwa/manga site implementations.
 * All site-specific adapters must extend this class and implement all methods.
 */
class SiteAdapter {
    constructor(siteConfig = {}) {
        this.config = siteConfig;
        this.name = siteConfig.name || 'Unknown Site';
        this.domains = siteConfig.domains || [];
    }

    /**
     * Check if this adapter handles the given URL
     * @param {string} url - The URL to check
     * @returns {boolean} - True if this adapter handles this URL
     */
    matchesUrl(url) {
        if (!url) return false;
        return this.domains.some(domain => {
            const pattern = new RegExp(`https?://[^/]*${domain.replace(/\./g, '\\.')}`, 'i');
            return pattern.test(url);
        });
    }

    /**
     * Get the manhwa title from the page
     * @returns {string} - The title or 'Unknown Title'
     */
    getTitle() {
        const selectors = this.getTitleSelectors();
        for (const selector of selectors) {
            const element = document.querySelector(selector);
            if (element && element.textContent?.trim()) {
                return element.textContent.trim();
            }
        }
        // Fallback to page title
        const pageTitle = document.title;
        if (pageTitle) {
            const parts = pageTitle.split(/[-–—\|]/);
            return parts[0].trim();
        }
        return 'Unknown Title';
    }

    /**
     * Extract the chapter number from a chapter URL or name
     * @param {string} url - Chapter URL
     * @param {string} name - Chapter name (optional fallback)
     * @returns {number|string|null} - Chapter number or null if not found
     */
    extractChapterNumber(url, name = '') {
        if (!url) return null;
        
        try {
            const urlObj = new URL(url);
            const pathSegments = urlObj.pathname.split('/').filter(s => s.length > 0);
            const lastSegment = pathSegments.pop();

            if (lastSegment) {
                // Try chapter-number pattern
                const chapterMatch = lastSegment.match(/^chapter-([\d\.]+)/i);
                if (chapterMatch) return parseFloat(chapterMatch[1]);

                // Try pure number pattern
                if (/^[\d\.]+$/.test(lastSegment)) return parseFloat(lastSegment);
            }
        } catch (e) {
            // Invalid URL, fall through
        }

        // Fallback: try to extract from name
        if (name) {
            const nameMatch = name.match(/^[\d\.]+/);
            if (nameMatch) return parseFloat(nameMatch[0]);
        }

        return null;
    }

    // Abstract methods - must be implemented by subclasses
    
    /**
     * Get CSS selectors for finding chapter list
     * @returns {string[]} - Array of CSS selectors to try
     */
    getChapterListSelectors() {
        throw new Error('getChapterListSelectors() must be implemented by subclass');
    }

    /**
     * Get CSS selectors for finding the manhwa title
     * @returns {string[]} - Array of CSS selectors to try
     */
    getTitleSelectors() {
        throw new Error('getTitleSelectors() must be implemented by subclass');
    }

    /**
     * Get CSS selectors for finding chapter images
     * @returns {string[]} - Array of CSS selectors to try
     */
    getImageSelectors() {
        throw new Error('getImageSelectors() must be implemented by subclass');
    }

    /**
     * Check if a URL matches the chapter pattern for this site
     * @param {string} url - URL to check
     * @returns {boolean} - True if URL is a chapter URL
     */
    isChapterUrl(url) {
        throw new Error('isChapterUrl() must be implemented by subclass');
    }

    /**
     * Extract and clean chapter name from link text
     * @param {string} text - Raw link text
     * @returns {string} - Cleaned chapter name
     */
    cleanChapterName(text) {
        if (!text) return 'Unknown Chapter';
        return text.replace(/^chapter\s+/i, '').replace(/^ch\.\s*/i, '').trim();
    }

    /**
     * Get download configuration for this site
     * @returns {Object} - Download settings
     */
    getDownloadConfig() {
        return {
            maxConcurrentTabs: 3,
            tabLoadTimeoutMs: 60000,
            scriptResponseTimeoutMs: 30000,
            imageFetchTimeoutMs: 45000,
            imageFetchRetries: 3,
            imageRetryDelayMs: 1000,
            delayBetweenTaskStartMs: 200,
            delayAfterTaskFinishMs: 500,
            zipCompressionLevel: 6,
            ...(this.config.download || {})
        };
    }

    /**
     * Get file naming pattern
     * @returns {Object} - Naming patterns
     */
    getNamingPattern() {
        return {
            chapterFolder: 'Chapter_{number}',  // Available: {number}, {name}, {title}
            imageFile: '{number}.{extension}',  // Available: {number}, {extension}
            zipFile: '{title}_Chapter_{number}.zip',
            ...(this.config.naming || {})
        };
    }

    /**
     * Get the image URL from an image element
     * Handles lazy loading attributes
     * @param {HTMLElement} img - Image element
     * @returns {string|null} - Image URL or null
     */
    getImageUrl(img) {
        if (!img) return null;
        
        const url = img.dataset?.src || 
                    img.dataset?.lazySrc || 
                    img.getAttribute('data-src') || 
                    img.getAttribute('data-lazy-src') || 
                    img.src;
        
        if (url && typeof url === 'string' && url.startsWith('http')) {
            return url.trim();
        }
        return null;
    }

    /**
     * Validate that a chapter link element is valid
     * Override for site-specific validation
     * @param {HTMLElement} link - Link element
     * @param {string} url - URL
     * @returns {boolean} - True if valid chapter link
     */
    isValidChapterLink(link, url) {
        // Default: check if it's within a list item
        return !!link.closest('li');
    }

    /**
     * Sort chapters in ascending order
     * Override for site-specific sorting
     * @param {Array} chapters - Array of chapter objects {name, url}
     * @returns {Array} - Sorted chapters
     */
    sortChapters(chapters) {
        return chapters.sort((a, b) => {
            const numA = this.extractChapterNumber(a.url, a.name);
            const numB = this.extractChapterNumber(b.url, b.name);

            if (numA !== null && numB !== null) {
                return numA - numB;
            }

            // Fallback: sort by name
            return a.name.localeCompare(b.name);
        });
    }

    /**
     * Download a chapter
     * Each adapter implements its own download logic
     * This is the COMPLETE download flow - from getting images to triggering download
     * 
     * @param {Object} chapterData - Chapter info {name, url, index}
     * @param {string} seriesTitle - The series title
     * @param {Function} updateStatus - Callback to update UI status (optional)
     * @param {Object} options - Additional options {downloadState, sendPopupMessage, etc.}
     * @returns {Promise<Object>} - Result {status: 'success'|'failed'|'skipped', chapterName, failedImages, error}
     */
    async downloadChapter(chapterData, seriesTitle, updateStatus, options = {}) {
        throw new Error('downloadChapter() must be implemented by subclass');
    }
}

// Make available globally for use in other scripts
try {
    if (typeof window !== 'undefined') {
        window.SiteAdapter = SiteAdapter;
    }
    if (typeof globalThis !== 'undefined') {
        globalThis.SiteAdapter = SiteAdapter;
    }
    if (typeof self !== 'undefined') {
        self.SiteAdapter = SiteAdapter;
    }
} catch (e) {
    console.error("[SiteAdapter] Failed to set global:", e);
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SiteAdapter;
}

// sites/WebtoonscanContentAdapter.js
// Content script adapter - scraping only (no download logic)
// Used by content.js

class WebtoonscanContentAdapter extends SiteAdapter {
    constructor(siteConfig = {}) {
        super({
            name: 'Webtoonscan',
            domains: ['webtoonscan.com', 'cdn4.webtoonscan.com'],
            ...siteConfig
        });
    }

    isChapterListingPage(url) {
        if (!url) return false;
        return url.includes('webtoonscan.com/manhwa/') && !this.isChapterUrl(url);
    }

    getChapterListSelectors() {
        return [
            'div.page-content-listing.single-page ul.main.version-chap li.wp-manga-chapter a',
            'div.listing-chapters_wrap ul li a',
            'div.version-chap ul li a',
            'ul.version-chap li a'
        ];
    }

    getTitleSelectors() {
        return [
            'h1.post-title',
            '.post-title h1',
            '.post-title h3',
            '.entry-title',
            '.main-info .container h1'
        ];
    }

    getImageSelectors() {
        return [
            'div.reading-content div.page-break img.wp-manga-chapter-img',
            'div.read-container img.viewer-image'
        ];
    }

    isChapterUrl(url) {
        if (!url) return false;
        
        try {
            const urlObj = new URL(url);
            const pathSegments = urlObj.pathname.split('/').filter(s => s.length > 0);
            const lastSegment = pathSegments.pop();

            if (lastSegment) {
                const isChapterPattern = /^chapter-[\d\.]+$/i.test(lastSegment) || 
                                        /^[\d\.]+$/.test(lastSegment);
                return isChapterPattern && url.includes('webtoonscan.com');
            }
        } catch (e) {
            return false;
        }
        return false;
    }

    isValidChapterLink(link, url) {
        const parent = link.closest('li.wp-manga-chapter, li');
        if (!parent) return false;
        const text = link.textContent?.trim();
        if (!text || text.length === 0) return false;
        return true;
    }

    extractChapterNumberFromUrl(url) {
        if (!url) return null;
        
        try {
            const urlObj = new URL(url);
            const pathSegments = urlObj.pathname.split('/').filter(s => s.length > 0);
            const lastSegment = pathSegments.pop();

            if (lastSegment) {
                const chapterMatch = lastSegment.match(/^chapter-([\d\.]+)/i);
                if (chapterMatch) return parseFloat(chapterMatch[1]);
                if (/^[\d\.]+$/.test(lastSegment)) return parseFloat(lastSegment);
            }
        } catch (e) {
            return null;
        }
        return null;
    }

    getChapters() {
        const chapters = [];
        const selectors = this.getChapterListSelectors();
        const uniqueUrls = new Set();

        for (const selector of selectors) {
            const links = document.querySelectorAll(selector);
            
            for (const link of links) {
                const url = link.href?.trim();
                if (!url) continue;
                if (!this.isChapterUrl(url)) continue;
                if (!this.isValidChapterLink(link, url)) continue;
                if (uniqueUrls.has(url)) continue;

                const name = this.cleanChapterName(link.textContent);
                chapters.push({ name, url });
                uniqueUrls.add(url);
            }
        }

        return this.sortChapters(chapters);
    }

    getChapterImages() {
        const images = [];
        const selectors = this.getImageSelectors();

        for (const selector of selectors) {
            const imageElements = document.querySelectorAll(selector);
            
            for (const img of imageElements) {
                const url = this.getImageUrl(img);
                if (url) {
                    images.push(url);
                }
            }

            if (images.length > 0) break;
        }

        return images;
    }

    sortChapters(chapters) {
        return chapters.sort((a, b) => {
            const numA = this.extractChapterNumberFromUrl(a.url);
            const numB = this.extractChapterNumberFromUrl(b.url);

            if (numA !== null && numB !== null) {
                return numA - numB;
            }

            const nameNumA = parseFloat(a.name.match(/^[\d\.]+/)?.[0]);
            const nameNumB = parseFloat(b.name.match(/^[\d\.]+/)?.[0]);

            if (!isNaN(nameNumA) && !isNaN(nameNumB)) {
                return nameNumA - nameNumB;
            }

            return a.name.localeCompare(b.name);
        });
    }
}

class AsuraScansContentAdapter extends SiteAdapter {
    constructor(siteConfig = {}) {
        super({
            name: 'AsuraScans',
            domains: ['asuracomic.net', 'beta.asuracomic.net'],
            ...siteConfig
        });
    }

    isChapterListingPage(url) {
        if (!url) return false;
        return url.includes('/series/') && !this.isChapterUrl(url);
    }

    getChapterListSelectors() {
        return [
            'div[class*="space-y-"] a[href*="/chapter/"]',
            'div.max-h-\\[20rem\\] a[href*="/chapter/"]'
        ];
    }

    getTitleSelectors() {
        return [
            'span.text-xl.font-bold',
            'h1.text-xl.font-bold'
        ];
    }

    getImageSelectors() {
        return [
            'div.py-8 img.object-cover',
            'div.py-8 img'
        ];
    }

    isChapterUrl(url) {
        if (!url) return false;
        
        try {
            const urlObj = new URL(url);
            const pathSegments = urlObj.pathname.split('/').filter(s => s.length > 0);
            
            // Pattern: /series/{slug}/chapter/{number}
            const chapterIndex = pathSegments.indexOf('chapter');
            if (chapterIndex !== -1 && chapterIndex + 1 < pathSegments.length) {
                const chapterNum = pathSegments[chapterIndex + 1];
                return /^\d+$/.test(chapterNum) && url.includes('asuracomic.net');
            }
        } catch (e) {
            return false;
        }
        return false;
    }

    isValidChapterLink(link, url) {
        if (!url || !url.includes('/chapter/')) return false;
        const text = link.textContent?.trim();
        return text && text.length > 0;
    }

    extractChapterNumberFromUrl(url) {
        if (!url) return null;
        
        try {
            const urlObj = new URL(url);
            const pathSegments = urlObj.pathname.split('/').filter(s => s.length > 0);
            const chapterIndex = pathSegments.indexOf('chapter');
            
            if (chapterIndex !== -1 && chapterIndex + 1 < pathSegments.length) {
                return parseFloat(pathSegments[chapterIndex + 1]);
            }
        } catch (e) {
            return null;
        }
        return null;
    }

    getChapters() {
        const chapters = [];
        const selectors = this.getChapterListSelectors();
        const uniqueUrls = new Set();

        for (const selector of selectors) {
            const links = document.querySelectorAll(selector);
            
            for (const link of links) {
                const url = link.href?.trim();
                if (!url) continue;
                if (!this.isChapterUrl(url)) continue;
                if (!this.isValidChapterLink(link, url)) continue;
                if (uniqueUrls.has(url)) continue;

                const name = this.cleanChapterName(link.textContent);
                chapters.push({ name, url });
                uniqueUrls.add(url);
            }
        }

        return this.sortChapters(chapters);
    }

    getChapterImages() {
        const images = [];
        const selectors = this.getImageSelectors();

        for (const selector of selectors) {
            const imageElements = document.querySelectorAll(selector);
            
            for (const img of imageElements) {
                const url = this.getImageUrl(img);
                if (url) {
                    // Filter out end page image
                    if (!url.includes('EndDesign')) {
                        images.push(url);
                    }
                }
            }

            if (images.length > 0) break;
        }

        return images;
    }

    sortChapters(chapters) {
        return chapters.sort((a, b) => {
            const numA = this.extractChapterNumberFromUrl(a.url);
            const numB = this.extractChapterNumberFromUrl(b.url);

            if (numA !== null && numB !== null) {
                return numB - numA; // Descending (newest first)
            }

            const nameNumA = parseFloat(a.name.match(/^[\d\.]+/)?.[0]);
            const nameNumB = parseFloat(b.name.match(/^[\d\.]+/)?.[0]);

            if (!isNaN(nameNumA) && !isNaN(nameNumB)) {
                return nameNumB - nameNumA;
            }

            return a.name.localeCompare(b.name);
        });
    }
}

if (typeof window !== 'undefined') window.AsuraScansContentAdapter = AsuraScansContentAdapter;
if (typeof globalThis !== 'undefined') globalThis.AsuraScansContentAdapter = AsuraScansContentAdapter;
if (typeof self !== 'undefined') self.AsuraScansContentAdapter = AsuraScansContentAdapter;

// ============ SITE REGISTRY ============

// sites/SiteRegistry.js
// Registry for managing site adapters

'use strict';

/**
 * Registry for managing site adapters
 * Provides methods to register adapters and detect which adapter handles a URL
 */
class SiteRegistry {
    constructor() {
        this.adapters = new Map();
        this.defaultAdapter = null;
    }

    /**
     * Register a site adapter
     * @param {string} name - Unique name for the site
     * @param {SiteAdapter} adapter - The adapter instance
     * @param {boolean} isDefault - Whether this is the default adapter
     */
    register(name, adapter, isDefault = false) {
        if (!name || !adapter) {
            throw new Error('SiteRegistry: name and adapter are required');
        }

        this.adapters.set(name, adapter);
        
        if (isDefault || !this.defaultAdapter) {
            this.defaultAdapter = adapter;
        }

        console.log(`[SiteRegistry] Registered adapter: ${name}`);
    }

    /**
     * Get an adapter by name
     * @param {string} name 
     * @returns {SiteAdapter|null}
     */
    get(name) {
        return this.adapters.get(name) || null;
    }

    /**
     * Find the adapter that handles a given URL
     * @param {string} url 
     * @returns {SiteAdapter|null}
     */
    findAdapterForUrl(url) {
        if (!url) return null;

        for (const [name, adapter] of this.adapters) {
            if (adapter.matchesUrl(url)) {
                return adapter;
            }
        }

        return null;
    }

    /**
     * Check if a URL is supported by any registered adapter
     * @param {string} url 
     * @returns {boolean}
     */
    isSupported(url) {
        return this.findAdapterForUrl(url) !== null;
    }

    /**
     * Get all registered adapter names
     * @returns {string[]}
     */
    getRegisteredSites() {
        return Array.from(this.adapters.keys());
    }

    /**
     * Get adapter for chapter listing page
     * @param {string} url 
     * @returns {SiteAdapter|null}
     */

    /**
     * Get adapter for chapter reader page
     * @param {string} url 
     * @returns {SiteAdapter|null}
     */

    /**
     * Initialize registry with default adapters
     * Called once on extension load
     */
}

const siteRegistry = new SiteRegistry();

// Override: use ContentAdapter for content script
siteRegistry.initialize = function() {
    this.adapters.clear();
    if (typeof WebtoonscanContentAdapter !== 'undefined') this.register('webtoonscan', new WebtoonscanContentAdapter(), true);
    if (typeof AsuraScansContentAdapter !== 'undefined') this.register('asurascans', new AsuraScansContentAdapter(), true);
};

siteRegistry.initialize();

// ============ CONTENT SCRIPT LOGIC ============

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === "getChapters") {
        console.log("[Content Script] Received request: getChapters");
        
        try {
            const currentUrl = window.location.href;
            const adapter = siteRegistry.findAdapterForUrl(currentUrl);
            
            if (!adapter) {
                console.error("[Content Script] No adapter found for URL:", currentUrl);
                sendResponse({ 
                    action: "error",
                    error: `No adapter found for this site: ${currentUrl}`,
                    title: 'Unknown',
                    chapters: []
                });
                return true;
            }
            
            console.log(`[Content Script] Using adapter: ${adapter.name}`);
            
            const chapters = adapter.getChapters();
            console.log(`[Content Script] Found ${chapters.length} chapters.`);
            
            const title = adapter.getTitle();
            
            sendResponse({ 
                action: "chaptersFound",
                title: title,
                chapters: chapters,
                siteName: adapter.name
            });
            
        } catch (error) {
            console.error("[Content Script] Error:", error);
            sendResponse({ 
                action: "error",
                error: error.message,
                title: 'Unknown',
                chapters: []
            });
        }
        
        return true;
    }
    
    return false;
});

chrome.runtime.sendMessage({ action: "contentScriptReady", url: window.location.href });
console.log("[Content Script] Ready");
